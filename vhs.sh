#!/bin/bash
#
# This script requires TUI : https://github.com/sri-arjuna/tui
#
#
#	File:		/home/sea/.local/bin/vhs
#	Author: 	Simon Arjuna Erat (sea)
#	Contact:	erat.simon@gmail.com
#	License:	GNU Lesser General Public License (LGPL)
#	Created:	2014.05.18
#	Changed:	2014.05.29
	script_version=0.5.3
	TITLE="Video Handler Script by sea"
#	Description:	All in one movie handler, wrapper for ffmpeg
#			Simplyfied commands for easy use
#
#			It should encode a DVD with your prefered language only - when called from terminal,
#			but let you choose which languages, when your prefered langauge is not found.
#
#			Easy mass re-code files as it takes each file's name as replaces its container extension for the output.
#			If that new name exists, it numbers it incremently, so you cannot delete your input file by accident (from the script
#
#	Resources:	http://ffmpeg.org/index.html
#			https://wiki.archlinux.org/index.php/FFmpeg
#			https://support.google.com/youtube/answer/1722171?hl=en&ref_topic=2888648
#
#
#	Check if TUI is installed...
#
	S=/etc/profile.d/tui.sh
	if [[ ! -f $S ]]
	then 	[[ 0 -eq $UID ]] || \
			( printf "\n#\n#\tPlease restart the script as root to install TUI (Text User Interface).\n#\n#\n" ; exit 1 )
		git clone https://github.com/sri-arjuna/tui.git /tmp/tui.inst
    		sh /tmp/tui.inst/install.sh || \
    			(printf "\n#\n#\tPlease report this issue.\n#\n#\n";exit 1)
    	fi
    	source $S
#
#	Script Environment
#
	ME="${0##*/}"				# Basename of $0
	ME="${ME/.sh/}"				# Cut off .sh extension
	#ME_DIR="${0/${0##/*/}}"			# Dirname of $0
	CONFIG="$HOME/.config/$ME/$ME.conf"	# Configuration file
	LIST_FILE="${CONFIG:0:(-4)}list"	# Contains lists of codecs, formats
	LOG="${CONFIG:0:(-4)}log" 		#-$(date +'%T')	# If a daily log is prefered
	TMP="${CONFIG:0:(-4)}tmp"
	CONTAINER="$(dirname $CONFIG)/containers"
	sleep_between=3
	[[ -f "$CONFIG" ]] && container=$(tui-value-get "$CONFIG" "container")
#
#	Help text
#
	help_text="
$ME ($script_version)
${TITLE^}
Usage: 		$ME [options] [arguments]
Examples:	$ME -b a128 -b v512 filename	| Encode file with audio bitrate of 128k and video bitrate of 512k
		$ME -Cvwe webm *ogg		| Fake encodes all files ending with ogg as webm, 
						+ optimized to be played in a browser/stream, while beeing verbose
		$ME filename			| Encodes a file
		$ME -DC filename		| Fake encode a DVD
		$ME -s				| Captures screen
		$ME -W				| Captures webcam
Where options are:
	-h(elp) 			This screen
	-b(itrate)	[av]ARG		Set Bitrate to ARG kilobytes, use either 'a' or 'v' to define audio or video bitrate
	-B(itrate)			Use bitrates (av) from configuration
	-C(opy)				Just copy streams, fake convert
	-c(odec)	[av]ARG		Set codec to ARG for audio or video
	-e(xtension)	ARG		Use this container (ARG) instead of \"$container\"
	-L(OG)				Show the log file
	-Q(uality)	ARG		This is ment to use with -D.
					One of: CLIP DVD BR HD
					CLIP=	640x480
					DVD=	720x576
					BR=	1280x720
					HD=	1920x1080
	-s(creen)			Records the fullscreen desktop
	-S(etup)			Shows the setup dialog
	-v(erbose)			Displays encode data from ffmpeg
	-w(eb)				Optimizes for web usage
(BETA)	-W(ebcam)			Encodes from webcam

-- NON-FUNCTIONAL ??
	-D(VD)				Encode from DVD


Info:
------------------------------------------------------
After installing codecs, drivers or plug in of webcam,
it is highy recomended to update the list file.
You can do so by entering the Setup dialog: $ME -S
and select 'UpdateLists'.

Recording from webcam does a terminal lockup on my system.
However, forum users confirmed that the default example
command works, thus, i'm currently let you use that one,
rather than the command generated by the script.


Files:		
------------------------------------------------------
Script:		$0
Config:		$CONFIG
Containers:	$CONTAINER
Lists:		$LIST_FILE
Log:		$LOG

"
#
#	Variables
#
	REQUIRES="ffmpeg v4l-utils"		# This is absolutly required 
	REQUIRED=""				# Will be filled, if missing
#
#	Defaults, do not change
#
	doCopy=false
	doQuality=false
	show_menu=false
	BIT_VIDEO=768
	BIT_AUDIO=192	# Equals ~1 MB in total
	override_video_bit=false
	override_audio_bit=false
	override_video_codec=false
	override_audio_codec=false
	override_container=false
	extra=""
	verbose=" -v quiet"	# -hide-banner
	web=""
	mode="file"
	QUALITY=""
#
#	Functions
#
	doLog() { # "MESSAGE STRING"
	# Prints: Time & "Message STRING"
	# See 'tui-log -h' for more info
		tui-log -t "$LOG" "$1"
	}
	GetQuality() { # ABR
	# This will override the sources specifications
	#
		[[ "-h" = "$1" || "list" = "$1" ]] && \
			printf "CLIP DVD BR HD WEBCAM WEBCAMSD WEBCAMHD"
		WH=( $(xrandr|grep \*|sed s,x,' ',g|awk '{print $1" "$2}') )
		vbits=$[ ${WH[0]} / 2  ]
		
		# VAR	WIDTH 	HEIGHT 	A-BIT 	V-BIT
		SCREEN="${WH[0]} ${WH[1]} 128 $vbits"
		CLIP="	640	480	112	384"
		DVD="	720	576	128	512"
		BR="	1280	720	256	1024"
		HD="	1920	1080	256	1536"
		
		out=$(  eval echo "\$$1"  )
		printf "$out"|awk '{print "-s "$1"x"$2" -b:a "$3" -b:v "$4}'
	}
	genFilename() { # Filename container
	# Parses for file extension and compares with new container
	# If identical, add a number to avoid overwriting sourcefile.
		video="$1"
		container="$2"
		for ext in $(printf "$video"|sed s,'\.',' ',g);do printf "" > /dev/zero;done
		if [[ $ext = $container ]]
		then 	# new file name would be the same
			name="${video/$ext/}"
			N=0
			while [[ -f "$name$N.$container" ]] ; do ((N++));done
			outputfile="$name$N.$container"
			doLog "Output: Has same extension, incrementing to \"$outputfile\""
		else 	outputfile="${video/$ext/}$container"
			doLog "Output: \"$outputfile\""
		fi
		printf "$outputfile"
	}
	hasMultipleStreams() { # [/path/to/]filename
	# If more than one audio stream is found, returns success (0)
	#
		touch "$TMP"
		ffmpeg -psnr -i "$1"  2>&1 | grep Stream |grep Audio > "$TMP"
		lines=$(cat "$TMP"|wc -l)
		[[ $lines -gt 1 ]] && \
			doLog "Audio: Multiple streams found" && \
			return 0			
		return 1
	}
	hasDTS() { # filename
	# Checks if filename-video has audio streams with dts
	#
		touch "$TMP.dts"
		grep -i dts "$TMP" > "$TMP.dts"
		lines=$(cat "$TMP.dts"|wc -l)
		[[ $lines -gt 1 ]] && \
			doLog "Audio: DTS encoding found" && \
			return 0			
		return 1
	}
	hasLang() { # filename
	# checks if filename-video has favorite language audio stream
	#
		num=$(grep "($lang)" "$TMP"|wc -l)
		[[ ! -z $num ]] && \
			doLog "Audio: Found $num entry for \"$lang\"" && \
			return 0			
		return 1
	}
	WriteContainers() { # 
	# Writes several container files and their default / suggested values
	#
		tui-title "Write Containers"
		header="# $ME ($script_version) - Container definition"
		[[ -d "$CONTAINER" ]] || mkdir -p "$CONTAINER"
		cd "$CONTAINER"
		for entry in avi mp4 mkv ogg webm;do
			case $entry in
			avi)	ca=mpeg2video 	# Codec Audio
				cv=mp3		# Codec Video
				ce=false	# Codec extra
				fe=true		# File extra (audio codec dependant)
				ba=		# Bitrate Audio
				bv=		# Bitrate Video
				q=CLIP		# Set container quality
				;;
			dvd)	ca=mpeg2video
				cv=mp3	
				ce=""	
				fe=""	
				ba=""
				bv=""
				q=DVD
				;;
			mp4)	ca=aac	
				cv=libx264
				ce=true	
				fe=true	
				ba=""
				bv=""
				q=BR
				;;
			mkv)	ca=ac3	
				cv=libx264
				ce=false
				fe=false
				ba=""
				bv=""
				q=HD
				;;
			ogg)	ca=vorbis
				cv=theora
				ce=true	
				fe=true		
				ba=""
				bv=""
				q=DVD
				;;
			webm)	ca=vorbis
				cv=libvpx	
				ce=true	
				fe=true	
				ba=""
				bv=""
				q=BR
				;;
			# blob)	ca=
			#	cv=
			#	ce=""
			#	fe=""
			#	ba=""
			#	bv=""
			#	q=CLIP
			#	;;
			esac
			touch $entry
			tui-printf "Write container info ($entry)" "$WORK"
			printf "$header\ncontainer=$entry\next=$entry\naudio_codec=$ca\nvideo_codec=$cv\nquality=$q\ncodec_extra=$ce\nfile_extra=$fe" > $entry
			tui-status $? "Wrote container info ($entry)" && \
				doLog "Container: Create $entry definitions (defaults)"
		done
	}
	UpdateLists() { #
	# Retrieve values for later use
	# Run again after installing new codecs or drivers
		[[ -f "$LIST_FILE" ]] || touch "$LIST_FILE"
		tui-title "Generating a list file"
		tui-progress "Retrieve raw data..."
		ffmpeg $verbose -codecs | grep \ DE > "$TUI_TEMP_FILE"
		sleep 0.3
		
		tui-progress "Saving Audio-codecs"
		audio_raw=$(grep DEA "$TUI_TEMP_FILE"|awk '{print $2}'|sed s,"\n"," ",g)
		audio=""
		for a in $audio_raw;do audio+=" $a";done
		printf "codecs_audio=\"$audio\"\n" > "$LIST_FILE"
		doLog "Lists : Updated Audio-Codecs"
		sleep 0.3
		
		tui-progress "Saving Video-codecs"
		video_raw=$(grep DEV "$TUI_TEMP_FILE"|awk '{print $2}'|sed s,"\n"," ",g)
		video=""
		for v in $video_raw;do video+=" $v";done
		printf "codecs_video=\"$video\"\n" >> "$LIST_FILE"
		doLog "Lists : Updated Video-Codecs"
		sleep 0.3
		
		tui-progress "Saving Subtitle-codecs"
		subtitle_raw=$(grep DES "$TUI_TEMP_FILE"|awk '{print $2}'|sed s,"\n"," ",g)
		subtitle=""
		for s in $subtitle_raw;do subtitle+=" $s";done
		printf "codecs_subtitle=\"$subtitle\"\n" >> "$LIST_FILE"
		doLog "Lists : Updated Subtitle-Codecs"
		sleep 0.3
		
		tui-progress "Saving Codecs-Format"
		ffmpeg $verbose -formats > "$TUI_TEMP_FILE"
		formats_raw=$(grep DE "$TUI_TEMP_FILE"|awk '{print $2}'|sed s,"\n"," ",g)
		formats=""
		for f in $formats_raw;do formats+=" $f";done
		printf "codecs_formats=\"$formats\"\n" >> "$LIST_FILE"
		doLog "Lists : Updated Codecs-Format"
		sleep 0.3
		
		if [[ -e /dev/video0 ]]
		then 	#v4l2-ctl cant handle video1 .. ??
			tui-progress "Saving WebCam-Formats"
			webcam_formats=""
			[[ -z $webcam_fps ]] && webcam_fps=5
			wf="$(v4l2-ctl --list-formats-ext|grep $webcam_fps -B4 |grep Siz|awk '{print $3}'|sort)"
			for w in $wf;do webcam_formats+=" $w";done
			printf "webcam_formats=\"$webcam_formats\"\n" >> "$LIST_FILE"
			doLog "Lists : Updated WebCam-Format"
			sleep 0.3
		
			tui-progress "Saving WebCam-frames"
			webcam_frames=""
			wf="$( v4l2-ctl --list-formats-ext|grep -A6 Siz|awk '{print $4}')"
			C=0
			for w in $wf;do webcam_frames+=" ${w/(/}";((C++));[[ $C -ge 6 ]] && break;done
			printf "webcam_frames=\"$webcam_frames\"\n"|sed s,"\.000","",g >> "$LIST_FILE"
			doLog "Lists : Updated WebCam-Frames"
			sleep 0.3
		fi
		tui-status $? "Updated $LIST_FILE"
	}
	MenuSetup() { # 
	# Configures the variables/files used by the script
	# 
	#
	#	Variables
	#
		source "$LIST_FILE" || UpdateLists
		[[ -f "$CONFIG" ]] || cat > "$CONFIG" << EOF
# $CONFIG, generated by $ME ($script_version)

# Available containers:
# -> avi mkv mp4 ogg webm
container=webm

# Audio bitrate suggested range (values examples): 72 96 128 144 192 256
BIT_AUDIO=$BIT_AUDIO

# Video bitrate suggested range (value examples): 128 256 512 768 1024 1280 1536 1920
BIT_VIDEO=$BIT_VIDEO

# See ffmpeg output for your language
lang=eng

# If DTS is found, to how many channels shall it 'downgrade'?
# Range::  1) Mono, 2) Stereo, [3-5]) dunno, 6) 5.1
channels=2

# This is a default value that should work on most webcams
webcam_res="640x480"
webcam_fps=25
EOF
	#
	#	Setup menu
	#
		VARS=$(tui-value-get -l "$CONFIG"|grep -v req)
		tui-title "Setup : $TITLE"
		
		oIFS="$IFS" ; IFS="="
		while read var val;do [[ ! "#" = "${var:0:1}" ]] && [[ ! "" = "$(printf \"${var}\")" ]] && tui-echo "$var" "$val" ; done < $CONFIG
		IFS="$oIFS"
		
		tui-echo
		tui-echo "Which variable to change?"
		select var in Back UpdateLists $VARS;do
			case $var in
			Back)		break	;;
			UpdateLists)	$var 	;;
			*)	val=$(tui-value-get "$CONFIG" "$var")
				tui-echo "${var^} is set to:" "$val"
				if tui-yesno "Change this value?"
				then	case $var in
					container)	tui-echo "Please select a new one:"
							select newval in $(cd "$(dirname $CONFIG)/containers";ls);do break;done
							;;
					channnels)	tui-echo "Please select a new amount:"
							select newval in $(seq 1 1 6);do break;done
							;;
					webcam_res)	tui-echo "Please select the new resolution:"
							select newval in $webcam_formats;do break;done
							;;
					webcam_fps)	tui-echo "Please select the new framerate:"
							select newval in $webcam_frames;do break;done
							;;
					*)		newval=$(tui-read "Please type new value:")
							;;
					esac
					msg="Changed \"$var\" from \"$val\" to \"$newval\""
					tui-value-set "$CONFIG" "$var" "$newval"
					tui-status $? "$msg" && \
						doLog "Setup: $msg" || \
						doLog "Setup: Failed to c$(printf ${msg:1}|sed s,ged,ge,g)"
				fi
			;;
			esac
			tui-echo "Press [ENTER] to see the menu:" "$INFO"
		done
	}
#
#	Environment checks
#
	# This is optimized for a one-time setup
	if [[ ! -f "$CONFIG" ]]
	then 	mkdir -p "$(dirname $CONFIG)"
		tui-header "$ME ($script_version)" "$(date +'%F %T')"
		tui-echo "Entering first time setup." "$SKIP"
		doLog "Setup : First config"
		WriteContainers
		UpdateLists
		sleep 0.5
		MenuSetup
		#
		#	Install missing packages
		#
			tui-progress -ri movies-req " "
			if [[ ! true = "$req_inst" ]]
			then 	doLog "Req : Checking for installed packages"
				for R in $REQUIRES;do
					tui-progress -i movies-req -m ${#REQUIRES} "Check requirements: $R"
					rpm -qa $F > /dev/zero || ( REQUIRED+=" $R" ; doLog "Req : Missing $R" )
				done
			fi
			if [[ ! " " = "$(printf "${REQUIRED} ")" ]]
			then 	tui-title "Installing missing packages"
				doLog "Req : Installing missing packages: $REQUIRED"
				sudo yum install -y $REQUIRED && \
					printf "req_inst=true\n" >> "$CONFIG"
				tui-status $? "Installed: $REQUIRED"
				[[ 0 -eq $? ]] && \
					ret_info="succeeded" || \
					ret_info="failed"
				doLog "Req: Installation of $REQUIRED $ret_info"
			else 	[[ ! true = "$req_inst" ]] && \
					printf "req_inst=true\n" >> "$CONFIG" && \
					doLog "Req : All required packages already installed"
			fi
		#
		#	Actualy entering the setup
		#
		exit $?
	fi
	source "$LIST_FILE"
	source "$CONFIG" || \
		( doLog "Failed to load: $CONFIG" ; tui-status 1 "Failed to load: $CONFIG" ; MenuSetup )
#
#	Catching Arguments
#
	tui-log -e "$LOG" "\r---- New call $$ ----"
	while getopts "aBb:c:CDe:hLSsQ:vwW" opt
	do 	case $opt in
		b)	case "${OPTARG:0:1}" in
			a)	override_audio_bit=true
				doLog "Options: Override audio bitrate ($BIT_AUDIO) with ${OPTARG:1}"
				BIT_AUDIO="${OPTARG:1}"
				;;
			v)	override_video_bit=true
				doLog "Options: Override video bitrate ($BIT_VIDEO) with ${OPTARG:1}"
				BIT_VIDEO="${OPTARG:1}"
				;;
			*)	tui-status 1 "You did not define whether its audio or video: -$opt [av]$OPTARG"
				exit 1
				;;
			esac
			;;
		B)	override_audio_bit=true
			override_video_bit=true
			BIT_AUDIO=$(tui-value-get "$CONFIG" "BIT_AUDIO")
			BIT_VIDEO=$(tui-value-get "$CONFIG" "BIT_VIDEO")
			doLog "Options: Using bitrates from $CONFIG (A:$BIT_AUDIO V:$BIT_VIDEO )"
			;;
		c)	case "${OPTARG:0:1}" in
			a)	override_audio_codec=true
				doLog "Options: Override audio bitrate ($audio_codec) with ${OPTARG:1}"
				audio_codec="${OPTARG:1}"
				;;
			v)	override_video_codec=true
				doLog "Options: Override video bitrate ($video_codec) with ${OPTARG:1}"
				video_codec="${OPTARG:1}"
				;;
			*)	tui-status 1 "You did not define whether its audio or video: -$opt [av]$OPTARG"
				exit 1
				;;
			esac
			;;
		C)	doCopy=true
			override_video_codec=true
			override_audio_codec=true
			video_codec=copy
			audio_codec=copy
			doLog "Options: Just copy streams, no encoding"
			;;
		D)	mode=dvd
			tempdata=( $(ls /run/media/$USER) )
			[[ "${#tempdata[@]}" -ge 2 ]] && \
				tui-echo "Please select which entry is the DVD:" && \
				select name in "${tempdata[@]}";do break;done || \
				name="$(printf $tempdata)"
			SCREEN_OF=$(genFilename "DVD-$tempdata.$container" $container )
			SCREENER=DVD
			override_container=true
			;;
		e)	override_container=true
			doLog "Options: Overwrite \"$container\" with \"$OPTARG\""
			container="$OPTARG"
			;;
		h)	printf "$help_text"
			exit $RET_HELP
			;;
		L)	less "$LOG"	
			exit $RET_DONE
			;;
		Q)	QUALITY=$(GetQuality "$OPTARG")
			doQuality=true	;;
		v)	doLog "Options: Be verbose!"
			verbose="-v info"		;;
		w)	doLog "Options: Optimize for web usage."
			web="-movflags faststart"	;;
		W)	mode=webcam
			SCREEN_OF=$(genFilename "webcam-out.$container" $container )
			SCREENER=webcam
			override_container=true
			;;
		s)	mode=screen
			SCREEN_OF=$(genFilename "screen-out.$container" $container )
			SCREENER=screen
			override_container=true
			;;
		S)	tui-header "$ME ($script_version)" "$(date +'%F %T')"
			MenuSetup
			exit 0	;;
		esac
	done
	shift $(($OPTIND - 1))
	ARGS=(${*})			# Remaining arguments
	ARGS_COUNT=${#ARGS[@]}		# Amount of remaining
#
#	Display & Action
#
	tui-header "$ME ($script_version)" "$(date +'%F %T')"
	tui-title "$TITLE"
#
#	Do this for every supplied argument
#
	[[ file = "$mode" ]] && \
		[[ -z "$1" ]] && \
		show_menu=true
#
#	Get 'best' codecs for $container, unless override is true
#	
	[[ -z $mode ]] && mode="file"
	doLog "Mode: $mode"
	[[ $override_container = true ]] && \
		doLog "Options: Set to $container" || \
		doLog "Container: $container (default)"
	if [[ true = $doCopy ]]
	then 	doLog "Options: Just copy streams..."
	elif [[ true = $doQuality ]]
	then 	source "$CONTAINER/$container"
	else	src="$CONTAINER/$container"
		bolCodecExtra=$(tui-value-get "$src" "codec_extra")
		bolFileExtra=$(tui-value-get "$src" "file_extra")
		
		[[ true = $override_video_codec ]] || video_codec=$(tui-value-get "$src" "video_codec")
		[[ true = $override_audio_codec ]] || audio_codec=$(tui-value-get "$src" "audio_codec")
		
		[[ true = $bolFileExtra ]] && ext=$(tui-value-get "$src" 'ext') && F="-f $ext"
		[[ true = $bolCodecExtra ]] && extra+=" -strict -2"
		
		# Special treatment
		case "$container" in
		"webm")	threads="$(grep proc /proc/cpuinfo|wc -l)" && threads=$[ $threads - 1 ] 
			#video_codec+=" -minrate $[ 8 * ${BIT_VIDEO} ] -maxrate $[ 8 * ${BIT_VIDEO} ] -bufsize $[ 8 * ${BIT_VIDEO} ]"
			video_codec+=" -minrate ${BIT_VIDEO} -maxrate ${BIT_VIDEO} -bufsize ${BIT_VIDEO}"
			video_codec+=" -threads $threads  -deadline realtime"
			audio_codec+=" -cpu-used $threads"
			;;
		esac
	fi
	lang=$(tui-value-get "$CONFIG" "lang")
#
#	Get bitrates
#
	bits+=" -b:a ${BIT_AUDIO}K"
	bits+=" -b:v ${BIT_VIDEO}K "
	[[ true = $doQuality ]] && bits="$QUALITY"	# Overwrite 
	
#
#	Show menu or go for the loop of files
#
	for video in "${@}" $SCREENER;do
	#
	#	per entry defaults
	#
		audio_streams=""
		skip=false	# Init var
	#
	#	New 'file' / only input
	#
		doLog "----- $video -----"
		tui-title "Input: $video"
		case $mode in
		screen|dvd|web)	OF="$HOME/$SCREEN_OF" ;;
		*)	#
			#	Verify Inputfile exists and outputfile has not the same name
			#	
				[[ -f "$video" ]] && \
					tui-status $? "Inputfile ($video) checked." && \
					doLog "Input Found: $video" || \
					( tui-status $? "Input ($video) not found!" ; doLog "Input Missing: $video" ; exit 1 )
				# Output File
				OF=$(genFilename "${video}" "$container")
			;;
		esac
	#
	#	Get audio stream
	#
		if hasMultipleStreams "$video"		# This also creates the $TMP file
		then	tui-title "Available audio streams"
			audio_streams="-map 0:0"	# Hardcode video stream ;)				
			CHANNELS="-ac "$(tui-value-get "$CONFIG" "channels")
			while read line;do tui-echo "$line";done<"$TMP"
			#tui-echo
			if hasLang "$video"
			then 	# Default langauge found
				msg="Auto-selected \"$lang\""
				check=$(grep -n "($lang)" "$TMP"|sed s,":"," ",g|awk '{print $1}')
				tui-status $? "$msg" && doLog "Audio: $msg"
				for c in $check;do audio_streams+=" -map 0:$c";done
			else	# No default language set or found
				# Let the user decide
				tui-echo "Select which streams you want to add (multiple are possible):"
				select stream in $(seq 1 1 $lines) Done;do
				case $stream in
				Done)	break	;;
				*)	printf "$stream"|grep [0-9] -q && \
						audio_streams+=" -map 0:$stream" && \
						doLog "Audio: Selected: $stream" || \
						tui-status 1 "Invalid input, try again."
					;;
				esac
				done
			fi
			hasDTS "$video" && \
				doChannels=true && \
				audio_streams+=" $CHANNELS"
		fi
		
		
		if [[ -f "$OF" ]]
		then 	if tui-yesno "Outputfile ($OF) exists, overwrite it?"
			then 	rm -f "$OF"
			else	skip=true
			fi
		fi
		
		if [[ false = $skip ]] 
		then 
		#
		#	Generate the command
		#
			msg="Begin:"
			case "$mode" in
			screen)		# Done
					msg+=" Capturing"
					tui-status $RET_INFO "Press 'q' to stop recording..."
					#[[ -z $container ]] && container=mkv
					#[[ -z $video_codec ]] && video_codec=ffvhuff 
					#[[ -z $audio_codec ]] && audio_codec=flac
					[[ -z $DISPLAY ]] && DISPLAY=":0.0"	# Should not happen, setting to default
					screen=" -f x11grab -video_size  $(xrandr|grep \*|awk '{print $1}') -i $DISPLAY -f alsa -i default -c:v $video_codec -c:a $audio_codec $bits"
					cmd="ffmpeg $verbose $screen $extra $web $F \"${OF}\""
					;;
			webcam)		# TODO
					# Done ?? dont work for me, but seems to for others
					msg+=" Capturing"
					tui-status $RET_INFO "Press 'q' to stop recording..."
					srcs=($(ls /dev/video*))
					case ${#srcs[@]} in
					1)	echo jup ;;
					esac
					if [[ "$(printf $srcs)" = "$(printf $srcs|awk '{print $1}')" ]]
					then 	input_video="$srcs"
					else	tui-echo "Please select the video source to use:"
						select input_video in $srcs;do break;done
					fi
					
					tui-status $RET_INFO "Standard is said to be working, sea's should - but might not, please report"
					select webcam_mode in standard sea;do
						case $webcam_mode in
						standard)	# Forum users said this line works
								doLog "Overwrite already generated name, for 'example' code.. "
								OF="$(genFilename output.mpg mpg)"
								cmd="ffmpeg $verbose -f v4l2 -s $webcam_res -i /dev/video0 $F \"${OF}\""
								;;
						sea)		# Non working ??
								OF="$SCREEN_OF"
								cmd="ffmpeg $verbose -f v4l2 -r $webcam_fps -s $webcam_res -i $input_video -f alsa -i default -acodec $audio_codec -vcodec $video_codec $extra $F \"${OF}\""
								;;
						esac
						doLog "WebCam: Using $webcam_mode command"
						break
					done
					;;
			dvd)		msg+=" Encoding"
					# If tempdir exists, good chances files were already copied
					#  cat f0.VOB f1.VOB f2.VOB | ffmpeg -i - out.mp2
					dvd_tmp="$HOME/.cache/$name"
					dvd_reuse=nothing
					errors=0
					
					dvd_base="/run/media/$USER/$name"
					input_vobs=$(find $dvd_base|grep -i vob)
					vobs=""
					vob_list=""
					total=0
					yadif="-vf yadif"
					for v in $input_vobs;do 
						if [[ $(ls -l $v|awk '{print $5}') -gt 700000000 ]]
						then 	vobs+=" -i ${v##*/}"
							vob_list+=" ${v##*/}"
							((total++))
						fi
					done
					
					# Cop vobs to local or directly from dvd?
					A="Encode directly from DVD"
					B="Copy largest files to local"
					tui-echo "Please select a method:"
					
					select dvd_copy in "$A" "$B";do
					case "$dvd_copy" in
					"$A")	cd "$dvd_base/VIDEO_TS"
						cmd="ffmpeg $verbose $vobs -acodec $audio_codec -vcodec $video_codec $extra $yadif $F \"${OF}\""
						;;
					"$B")	[[ -d "$dvd_tmp" ]] && \
					 	tui-yesno "$dvd_tmp already exists, reuse it?" && \
						dvd_reuse=true || \
						dvd_reuse=false
						# Create tempdir to copy vob files into
						if [[ false = $dvd_reuse ]]
						then 	mkdir -p "$dvd_tmp"
							doLog "DVD: Copy vobs to \"$dvd_tmp\""
							tui-echo "Copy vob files to \"$dvd_tmp\", this may take a while..." "$WORK"
							C=1
							for vob in $vob_list;do
								lbl="${vob##*/}"
								MSG1="Copy $lbl ($C / $total)"
								MSG2="Copied $lbl ($C / $total)"
								printf "cp -n \"$dvd_base/VIDEO_TS/$vob\" \"$dvd_tmp\"" > "$TMP"
								tui-bgjob -f "$dvd_tmp/$vob" "$TMP" "$MSG1" "$MSG2"
								if [[ 0 -eq $? ]] #"Copied $lbl"
								then 	doLog "DVD: ($C/$total) Successfully copied $lbl"
								else 	doLog "DVD: ($C/$total) Failed copy $lbl"
									((errors++))
								fi
								((C++))
							done
						fi
						tui-echo
						[[ $errors -ge 1 ]] && \
							tui-yesno "There were $errors errors, would you rather try to encode straight from the disc?" && \
							cd "$dvd_base/VIDEO_TS" || \
							cd "$dvd_tmp"
						cmd="ffmpeg $verbose $vobs -target film-dvd  -q:a 0  -q:v 0  $yadif $F \"${OF}\""
						;;
					esac
					break
					done
					doLog "DVD: Using \"$dvd_copy\" command"
					;;
			file)		# Done
					cmd="ffmpeg $verbose -i \"${video}\" $web $extra $bits -vcodec $video_codec -acodec $audio_codec $audio_streams $F \"${OF}\""
					msg+=" Converting"
					;;
			esac
			msg+=" from \"$video\" to \"$OF\""
			tui-printf "$msg" "$WORK"
			printf "$cmd" > "$TMP"
			doLog "$msg"
			doLog "Command: $cmd"
		#
		#	Execute the command
		#
			STR2="Converted \"$video\" to \"${OF##*/}\""
			STR1="Converting \"$video\" to \"${OF##*/}\""
			str="\$(ls -lh \"$OF\"|awk '{print \$5}')"
			if [[ $mode = "file" ]] || [[ $mode = "dvd" ]]
			then 	tui-bgjob -f "$OF" "$TMP" "$STR1" "$STR2"
				RET=$?
			else	sh "$TMP"
				tui-status $? "$STR2"
				RET=$?
				mkclean --optimize --remux "$OF"
			fi
		#
		#	Log if encode was successfull or not
		#	
			[[ 0 -eq $RET ]] && \
				ret_info="successfully (ret: $RET) \"$OF\"" || \
				ret_info="a faulty (ret: $RET) \"$video\""
			doLog "End: Encoded $ret_info "
			sleep $sleep_between
		else	msg="Skiped: $video"
			doLog "$msg"
			tui-status $RET_SKIP "$msg"
		fi
	done	
	if [[ $show_menu = true ]]
	then 	tui-status $RET_INFO "See $ME -h for help"
		tui-status 1 "Menu is not supported yet" || exit $?
		
		# Show menu
		# after 'generating' the basic variables
		tui-echo "Selected input:" "$video"
		# Verify output filename
		outputfile=$(genFilename "$video" "$container")
		tui-echo "What is the outputs name? (leave empty for: $outputfile)"
		newname=$(tui-read "Type the name:")
		[[ -z "$newname" ]] && newname="$outputfile"
		# If user has not passed file container / extension
		printf "$newname"|grep -q $container || newname+=".$container"
	fi
exit 0
